By the end of this video, you'll be able to design and build responsive websites that work on a 4K monitor, a tiny smartphone, and everything in between. Rule number one, think inside the box. To plan and design your layout, you need to think in terms of boxes because everything you see on a website is basically just a box. There's a big box that acts as the main parent. Then you have two boxes inside that parent holding different content. The first box or child, if we're being technically accurate, contains four more boxes. So, if you imagine it like a top- down family tree, there's a main parent with two children and the first child has four children. You only need to understand this parent child relationship to create responsive layouts. Like, can you answer why did the main parent have two children? Why can't we just wrap all the five children in the main box like this? Well, it's because these boxes have certain properties that control how they are displayed in the layout. To properly plan a responsive layout, you have to know these properties. The first one is display. And you can do a lot of things with it. Display none does exactly what it says. Completely removes the box from the layout. Display inline stays in the same line and only takes up as much space as needed. Display block is default of most elements. Block elements start on a new line and take up the full width available. Display inline block is a mix of inline and block. It lets boxes sit side by side like inline elements, but still allows you to set width, height, margin, and padding like block elements. Then there's display flex, which you apply to a parent box. This turns the parent into a flex container and its children into flex items. By default, the children act like inblock elements, but Flexbox unlocks powerful tools to arrange those items in a row or column and makes it much easier to handle alignment, spacing, and responsive behavior. And finally, there's display grid, which just like flexbox, makes the parent a grid container and the children grid items. It's mainly used for structured grid-like layouts where you need precise control over rows and columns, whereas flexbox is better for flexible layouts. In many cases, you can use flexbox or grid depending on what fits best. For example, we have these six boxes with random sizes as you would have on a real website. By default, these boxes will adapt to different screen sizes as they are block elements and will fill the available space available. But we have two issues with this default behavior. Firstly, the smaller ones are just wasting the space on the right. And secondly, the bigger ones look ugly and hard to read as we don't like to read long lines of text. To fix this issue, we are going to use rule number two. As we have seen earlier, everything you see on a website is just a box. Well, similarly, every single design can be broken into rows and columns. The width and number of columns will increase with screen width and the boxes will move into them resulting in a responsive layout. Because in a way a responsive layout is mostly about dynamically moving boxes into different rows and columns. Currently every box starts in a new row. Let's change that by applying display flex on the parent. That will align all the boxes in the row direction. And applying gap will create equal margins between them. You probably don't need six columns. So let's set flex wrap to wrap which is set to no wrap by default. Now we technically have a responsive layout. And in some cases, this is all you need. But these empty spaces are making the design ugly and chaotic. To fix this, we are going to look at three more properties that are crucial in designing responsive layouts. By default, these values are set to zero, one, and auto. As you already have guessed, zero means false and one means true. Flex Grow decides whether items will grow to fill the empty space. As you can see, if we set it to one, that will fill these empty spaces. Similarly, if we set flex shrink to zero, the boxes stop shrinking even when we run out of space. Flex basis is a percentage value and sets the starting size for these boxes. Kind of like setting a min width. If I set it to zero, then each box starts at zero width and then space is distributed proportionally by flex grow. You will see this clearly if I set flex grow to false and change the screen size. Items are taking as little space as possible. For our case, we want the boxes to start at their original size, then grow or shrink based on the available space. This is the most used combination when you want a flexible layout. And it can be written in a single line like this. Now let's see if we can achieve this flexible layout by using grid. I will remove all the flex related style and start from scratch. Just as we did with flexbox to create grid container, we apply display grid on the parent. Nothing happens. Well, if we apply a gap, we can see something did happen. It's just not as dramatic as flexbox. By default, you get a single column. Just as block elements, you have to tell it to create columns like this. FR is short for fraction. So, you are telling it to create two columns of 50% width. If you do one FR2 FR, you are creating three equal columns and assigning the last two columns to the second box. Similarly, you can put 20% 80% to make them 20% and 80% of screen size. What you can't do is create flexible column like you can use a repeat function with autofill and minmax to add some responsiveness, but this still looks like a grid and I don't mean it in a good way. If you really want to, you can manually set a span value on bigger children, but it's still nowhere near what we had with flexbox. So, if you want a flexible layout, use flexbox. And when you want full control over the children and need them to behave exactly how you want them to, use grid. We have this rigid grid-like structure by just using these three lines. Let's see how many lines it takes with flexbox. Three lines in the parent itself. Then maybe we change this flex basis to a fixed value like we did in grid. Not going to lie, this isn't bad at all. But we need a more rigid structure. How about we don't allow it to grow at all? Yeah, this kind of works. But what about this empty space? I guess if I try hard enough, I can fix it. But we're already at four lines of CSS with the children selector and shorthand of three different properties, while grid can do that in just three lines, all in the parent selector. Whether you use flexbox or grid, the design can be broken into rows and columns. Think flexbox or grid like a parent that owns the house and all children get their own rooms. Flex is that cool parent where the children have more freedom as they get to choose their room size and location. Whereas in the Grid's house, they all are more disciplined and obey their parents. There is a lot more to Flex and Grid than this simple explanation. But this is not a Flex versus Grid video, but the easy way to design and build responsive websites. That brings us to rule number three. I don't mean a pixel perfect or a polished design. You don't even need to open Figma if you don't want to. You just need a rough idea about the layout and how everything will respond on different screen sizes. Say you want to show a pricing section with three options. On mobile devices, you will have one column and on desktops three. But what about the middle? Or if you have a sidebar, how will it appear on a mobile device? Should you just toggle it or completely show a different UI? Doing all this directly in a code editor is timeconuming. So, it's very easy to settle for a good enough solution because of the sunk cost fallacy, but we all know it will keep bothering you until you rebuild it from scratch again. So, whenever you start a new project, first create a rough sketch of how the final design will look and respond to different screen sizes. And if you're feeling stuck, use Mobin, the sponsor of this video, to look up real world designs and analyze how they build responsive websites. Whether it's a dashboard or something specific like a pricing section we were discussing earlier, Mobin has a lot of helpful features to find exactly what you want. Say you are designing a finance app. Select it from app categories and you've got some of the best finance apps right in front of you. You can also filter by web or mobile. Then open something to get blown away by how easy it is to find hundreds of screens from a real product. But it gets better. You don't have to endlessly scroll to find something useful. You can get even more specific and exactly pinpoint what you want. Like you may want to design a powerful feature section. Once you find something interesting, save, download, or do whatever you want with it. But now you have a professional design that's tried and tested on real users. And that's what I love most about Mobin. Go try it for yourself and thank me later. Once you have a design or at least a rough idea how things will behave on different breakpoints, we can actually start coding. To keep things as simple as possible, I have already built a working prototype and isolated the key concepts that we will go through step by step. So, I am going to delete all the styles that were used to make this responsive. We are back to block elements. There are still some flex properties, but as you can see, they are not doing anything important as the design is all over the place. So let's start by fixing our header. We talked about boxes, parent child relationship and rows and columns. Can you tell me who is the parent and how many children they have? Header is the parent and I hope you answered three children because of these three separate columns. That brings me to rule number four. To apply any CSS, you are going to name them anyway. Why not use a name that is unique and more descriptive? That way it will be easier to debug the code later and you will avoid naming conflicts as well. So we have a header that has three children and as you can see there's a lot of moving pieces here. Let's cover them one by one. As you already have guessed we are using flex to align the children in a single row. Then to distribute them evenly we use a property called justify content that takes these values. Oh by the way I highly recommend this flexbox guide on csstrickicks.com. This will give you a starting point to start messing around and hopefully solidify core concepts. One of these concepts is space between. All this does is evenly distribute the leftover space between the children. Very handy for responsive layouts. Then we have another useful property that we talked about earlier. Flex grow will allow the middle child to grow and a max width will do exactly what it says. But flex and grid can only take you so far. As you can see, this behavior looks too complex for a flex or grid property. That brings us to the final rule. Media query let you apply different CSS properties based on a specific condition. For this video, we are going to use the screen width condition. If I set a max width and write some basic CSS, the browser will switch to this CSS when the condition is true. We can hide the search bar and stop it from growing by setting the flex grow back to zero. Then use the margin auto property to send it to the right and finally display none to hide the magic text. It's pretty straightforward but very powerful for achieving complex responsive behavior. Speaking of responsive behavior, we want this main UI to sit right next to the sidebar. Any idea how to do that? You must be thinking by using flex or grid, but there is only one right answer. We want the sidebar on the left and this main UI on the right filling this entire space. Does this sound like a flexible layout or grid? Here's a bonus rule. By default, use flexbox for everything until you specifically want a structured grid. So, this is the main container which will be the parent. Can you tell the immediate children? Think about it for a second. We want the sidebar on the left and the main UI on the right. So, of course, we need two children. What did I tell you in the beginning of the video? Display flex to align the children. flex grow of one as we want the main UI to cover everything and some gap to keep things clear. Now some very basic JavaScript and CSS to toggle sidebar. It's just a click event listener that is toggling display none on the sidebar. It's perfect on bigger screens but breaks the design on tablets and smartphones. So instead of shifting the UI, we can put the sidebar above the UI so it doesn't interfere with the rest of the layout. And to do that we are going to use the position property like we are doing with display. You can use it to control how these boxes are placed on the screen. By default every box just flows in the normal document order. Relative is also the same but you unlock four more properties to move the box. Absolute is a bit more dramatic and completely removes the box from the normal flow. But you can control it by assigning any non-static value to the parent. We will use it in a second. Fixed is almost identical to absolute, but you don't need any parent to control its positioning. Plus, as the name suggests, fixed boxes are always fixed and don't move on scroll. Sticky is a bit tricky. It will stay in the document flow and scroll normally, but then sticks to the position you assign to it, exactly what we did with our header and sidebar. We added a top zero on the header and 80 pixels on the sidebar to account for the header height. But make sure to set align self to flex start on sticky elements if the parent is a flexbox. It's just one of those little things that makes you love CSS even more. Anyway, we don't want the sidebar to break the design on smaller screens. So, let's take it out of the document flow. We also need some padding and background color to keep things legible. And that's all the media query we will need for this project. But the design is still breaking. And that's because of two reasons. First, the cascading part of CSS. So, it's recommended to move all your media query to the end so you don't accidentally overwrite something. And the second is a very common issue with absolute positioning. We applied it on the child, but the parent still has the static positioning by default. So, let's add a relative positioning to the container that holds our sidebar and the main UI. Speaking of main, I'm going to make it a flexbox and see what happens. Plus a border and gap to make things a bit clearer. I chose three children to achieve the responsive behavior I made in the sketch. Usually before writing any HTML, you should create a family tree like this. Go from top to bottom. At this point, define every parent child relationship in an easy to understand format. So you can come back and reference the document hierarchy to fix any issues. Currently, we have a lot of issues with our main UI. The first one being this empty space on the right. So let's set flex grow to one on all children. This solved our issue, but if you notice closely, stats and cards are not growing. And it's a very common gotcha behavior of flexbox. Just because there is room to grow doesn't mean all the items will grow equally. If you look at all three properties, flex basis is set to auto. So the flexbox algorithm does some calculations and gives the leftover space to the bigger child. In our case, I have assigned width 100% to this main chart. So it can respond to our screen size, but we can still control the layout however we want. For example, we can override this behavior by setting a fixed value to flex basis. This makes everything grow equally, but the chart is still the most important part of the UI. I said flex grow takes two values, zero or one. But actually, we can set flex grow to a bigger number as it's actually a proportional unit and comes in very handy for responsive layouts. Let's fix our tables so they grow to fill this empty space. On bigger screens, these two tables can be set in a single row. We can use flex or grid, whatever we want, but let's use grid this time. We start by setting display to grid and adding a gap to space things out. Then to create our columns, we declare grid template columns with a repeat function that takes two values, how many columns we want and their size. We want it to auto fit and the size can go from 400 to full width, but that might overflow on smaller screens. So, let's use a min function to handle that. This might look way more complicated than flexbox, and that's because it is, but it's also super useful. Take these cards for example. I've used the same repeat function for the columns. First, let's set flex wrap to wrap so the boxes can actually wrap into the next line. And because we used grid, you got same sized cards, whether it's a one column, two column, or three column layout. And with that, we've got a fully responsive UI that works on a big 4K monitor, a tiny smartphone, and everything in between. One size fits all. It's easy to build since you don't have to worry about millions of screen sizes out there. And it's great for user experience because your users can literally access your app from any device. Speaking of user experience, always include a theme toggle or at the very least adapt to the user's color scheme. Colors are honestly the easiest part of the UI and this toggle takes just a few minutes. If you want a dedicated video on colors, let me know in the comments just below the like and subscribe button.